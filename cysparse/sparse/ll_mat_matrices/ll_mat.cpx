from __future__ import print_function

########################################################################################################################
# CySparse cimport/import
########################################################################################################################
from cysparse.types.cysparse_types cimport *

from cysparse.sparse.ll_mat cimport LL_MAT_INCREASE_FACTOR

from cysparse.sparse.sparse_mat cimport unexposed_value
from cysparse.types.cysparse_numpy_types import are_mixed_types_compatible, cysparse_to_numpy_type
from cysparse.sparse.ll_mat cimport PyLLSparseMatrix_Check
from cysparse.sparse.sparse_mat_matrices.sparse_mat_@index@_@type@ cimport MutableSparseMatrix_@index@_@type@
from cysparse.sparse.ll_mat_matrices.ll_mat_@index@_@type@ cimport LLSparseMatrix_@index@_@type@
from cysparse.sparse.ll_mat_views.ll_mat_view_@index@_@type@ cimport LLSparseMatrixView_@index@_@type@



#from cysparse.sparse.csr_mat cimport MakeCSRSparseMatrix, MakeCSRComplexSparseMatrix
#from cysparse.sparse.csc_mat cimport MakeCSCSparseMatrix
#from cysparse.utils.equality cimport values_are_equal
#from cysparse.sparse.IO.mm cimport MakeLLSparseMatrixFromMMFile2, MakeMMFileFromSparseMatrix

from cysparse.sparse.sparse_utils.generate_indices_@index@ cimport create_c_array_indices_from_python_object_@index@

########################################################################################################################
# CySparse include
########################################################################################################################
# pxi files should come last (except for circular dependencies)
include "ll_mat_kernel/ll_mat_assignment_kernel_@index@_@type@.pxi"
include "ll_mat_kernel/ll_mat_multiplication_by_numpy_vector_kernel_@index@_@type@.pxi"
include "ll_mat_helpers/ll_mat_multiplication_@index@_@type@.pxi"


########################################################################################################################
# Cython, NumPy import/cimport
########################################################################################################################
# Import the Python-level symbols of numpy
import numpy as np

# Import the C-level symbols of numpy
cimport numpy as cnp

cnp.import_array()

from cpython.mem cimport PyMem_Malloc, PyMem_Realloc, PyMem_Free
from libc.stdlib cimport malloc,free, calloc
from libc.string cimport memcpy
from cpython cimport PyObject, Py_INCREF

########################################################################################################################
# External code include
########################################################################################################################
# TODO: use more internal CPython code
cdef extern from "Python.h":
    # *** Types ***
    int PyInt_Check(PyObject *o)
    int PyComplex_Check(PyObject * o)
    double PyComplex_RealAsDouble(PyObject *op)
    double PyComplex_ImagAsDouble(PyObject *op)
    PyObject* PyComplex_FromDoubles(double real, double imag)


cdef extern from "Python.h":
    PyObject* Py_BuildValue(char *format, ...)
    PyObject* PyList_New(Py_ssize_t len)
    void PyList_SET_ITEM(PyObject *list, Py_ssize_t i, PyObject *o)
    PyObject* PyFloat_FromDouble(double v)
    Py_complex PyComplex_AsCComplex(PyObject *op)

cdef extern from "complex.h":
    float crealf(float complex z)
    float cimagf(float complex z)
    double creal(double complex z)
    double cimag(double complex z)

########################################################################################################################
# CySparse cimport/import to avoid circular dependencies
########################################################################################################################
from cysparse.sparse.ll_mat_views.ll_mat_view_@index@_@type@ cimport LLSparseMatrixView_@index@_@type@, MakeLLSparseMatrixView_@index@_@type@


########################################################################################################################
# CLASS LLSparseMatrix
########################################################################################################################
cdef class LLSparseMatrix_@index@_@type@(MutableSparseMatrix_@index@_@type@):
    """
    Linked-List Format matrix.

    Note:
        Despite its name, this matrix doesn't use any linked list, only C-arrays.
    """
    ####################################################################################################################
    # Init/Free/Memory
    ####################################################################################################################
    def __cinit__(self,  **kwargs):
        """

        Args:
            no_memory: ``False`` by default. If ``True``, the constructor doesn't allocate any memory, otherwise,
            memory is preallocated for the internal C arrays. When no memory is allocated, a factory method **must** provide it!
        """
        if self.size_hint < 1:
            raise ValueError('size_hint (%d) must be >= 1' % self.size_hint)

        self.type = "LLSparseMatrix"
        self.type_name = "LLSparseMatrix [@index@, @type@]"

        # This is particular to the LLSparseMatrix type
        # Do we allocate memory here or
        # do we let another factory method do it for us?
        no_memory = kwargs.get('no_memory', False)

        cdef @index@ i

        if not no_memory:

            val = <@type@ *> PyMem_Malloc(self.size_hint * sizeof(@type@))
            if not val:
                raise MemoryError()
            self.val = val

            col = <@index@ *> PyMem_Malloc(self.size_hint * sizeof(@index@))
            if not col:
                raise MemoryError()
            self.col = col

            link = <@index@ *> PyMem_Malloc(self.size_hint * sizeof(@index@))
            if not link:
                raise MemoryError()
            self.link = link

            root = <@index@ *> PyMem_Malloc(self.nrow * sizeof(@index@))
            if not root:
                raise MemoryError()
            self.root = root

            self.nalloc = self.size_hint
            self.free = -1

            for i from 0 <= i < self.nrow:
                root[i] = -1

    def __dealloc__(self):
        """
        """
        PyMem_Free(self.val)
        PyMem_Free(self.col)
        PyMem_Free(self.link)
        PyMem_Free(self.root)

    cdef _realloc(self, @index@ nalloc_new):
        """
        Realloc space for the internal arrays.

        Note:
            Internal arrays can be expanded or shrunk.

        """
        cdef:
            void *temp

        temp = <@index@ *> PyMem_Realloc(self.col, nalloc_new * sizeof(@index@))
        if not temp:
            raise MemoryError()
        self.col = <@index@*>temp

        temp = <@index@ *> PyMem_Realloc(self.link, nalloc_new * sizeof(@index@))
        if not temp:
            raise MemoryError()
        self.link = <@index@ *>temp

        temp = <@type@ *> PyMem_Realloc(self.val, nalloc_new * sizeof(@type@))
        if not temp:
            raise MemoryError()
        self.val = <@type@ *>temp

        self.nalloc = nalloc_new

    cdef _realloc_expand(self):
        """
        Realloc space for internal arrays.

        Note:
            We use ``LL_MAT_INCREASE_FACTOR`` as expanding factor.

        """
        assert LL_MAT_INCREASE_FACTOR > 1.0
        cdef @index@ real_new_alloc = <@index@>(<FLOAT64_t>LL_MAT_INCREASE_FACTOR * self.nalloc) + 1

        return self._realloc(real_new_alloc)

    def compress(self):
        """
        Shrink matrix to its minimal size.

        """
        cdef:
            @index@ i, k, k_next, k_last, k_new, nalloc_new;

        nalloc_new = self.nnz  # new size for val, col and link arrays

        # remove entries with k >= nalloc_new from free list
        k_last = -1
        k = self.free
        while k != -1:
            k_next =  self.link[k]
            if k >= nalloc_new:
                if k_last == -1:
                    self.free = k_next
                else:
                    self.link[k_last] = k_next
            else:
                k_last = k
                k = k_next

        # reposition matrix entries with k >= nalloc_new
        for i from 0 <= i < self.nrow:
            k_last = -1
            k = self.root[i]
            while k != -1:
                if k >= nalloc_new:
                    k_new = self.free
                    if k_last == -1:
                        self.root[i] = k_new
                    else:
                        self.link[k_last] = k_new
                    self.free = self.link[k_new]
                    self.val[k_new] = self.val[k]
                    self.col[k_new] = self.col[k]
                    self.link[k_new] = self.link[k]
                    k_last = k_new
                else:
                    k_last = k

                k = self.link[k]

        # shrink arrays
        self._realloc(nalloc_new)

        return

    def memory_real(self):
        """
        Return the real amount of memory used internally for the matrix.

        Returns:
            The exact number of bits used to store the matrix (but not the object in itself, only the internal memory
            needed to store the matrix).

        """
        cdef @index@ total_memory = 0

        # root
        total_memory += self.nrow * sizeof(@index@)
        # col
        total_memory += self.nalloc * sizeof(@index@)
        # link
        total_memory += self.nalloc * sizeof(@index@)
        # val
        total_memory += self.nalloc * sizeof(@type@)

        return total_memory

    ####################################################################################################################
    # SUB-MATRICES
    ####################################################################################################################
    ####################################################################################################################
    #                                            ### CREATE ###
    # TODO: to be done
    cdef create_submatrix(self, PyObject* obj1, PyObject* obj2):
        raise NotImplemented("Not implemented yet...")
        cdef:
            @index@ nrow
            @index@ * row_indices,
            @index@ ncol
            @index@ * col_indices
            @index@ i, j

        row_indices = create_c_array_indices_from_python_object_@index@(self.nrow, obj1, &nrow)
        col_indices = create_c_array_indices_from_python_object_@index@(self.ncol, obj2, &ncol)

    ####################################################################################################################
    #                                            ### ASSIGN ###
    cdef assign(self, LLSparseMatrixView_@index@_@type@ view, object obj):
        """
        Set ``A[..., ...] = obj`` directly.

        Args:
            view: An ``LLSparseMatrixView_@index@_@type@`` that points to this matrix (``self``).
            obj: Any Python object that implements ``__getitem__()`` and accepts a ``tuple`` ``(i, j)``.

        Note:
            This assignment is done as if ``A[i, j] = val`` was done explicitely. In particular if ``store_zeros``
            is ``True`` and ``obj`` contains zeros, they will be explicitely added.

        Warning:
            There are not test whatsoever.
        """
        # test if view correspond...
        assert self == view.A, "LLSparseMatrixView should correspond to LLSparseMatrix!"

        # TODO: refine this method. It is too generic to do any optimization at all...

        # VIEW
        cdef:
            @index@ * row_indices = view.row_indices
            @index@ nrow = view.nrow
            @index@ * col_indices = view.col_indices
            @index@ ncol = view.ncol

        cdef:
            @index@ i, j

        if self.is_symmetric:
            if PyLLSparseMatrix_Check(obj):
                # obj is LLSparseMatrix
                for i from 0 <= i < nrow:
                    for j from 0 <= j <= i:
                        self.put(row_indices[i], col_indices[j], obj.at(i, j))

            else:
                for i from 0 <= i < nrow:
                    for j from 0 <= j <= i:
                        self.put(row_indices[i], col_indices[j], <@type@> obj[tuple(i, j)])

        else:   # self.is_symmetric == False

            if PyLLSparseMatrix_Check(obj):
                # obj is LLSparseMatrix
                for i from 0 <= i < nrow:
                    for j from 0 <= j < ncol:
                        self.put(row_indices[i], col_indices[j], obj.at(i, j))

            else:
                for i from 0 <= i < nrow:
                    for j from 0 <= j < ncol:
                        self.put(row_indices[i], col_indices[j], <@type@> obj[tuple(i, j)])

    ####################################################################################################################
    # COUNTING ELEMENTS
    ####################################################################################################################
    # TODO: to be done
    cdef count_nnz_from_indices(self, @index@ * row_indices,@index@ row_indices_length, @index@ * col_indices, @index@ col_indices_length):
        """
        Counts the nnz specified by row and column indices.

        Note:
            A row or column index can be repeated and indices are **not** supposed to be sorted.

        Warning:
            This method is costly, use with care.
        """
        raise NotImplemented("Not implemented yet...")

    ####################################################################################################################
    # Set/Get individual elements
    ####################################################################################################################
    ####################################################################################################################
    #                                            *** SET ***
    cdef put(self, @index@ i, @index@ j, @type@ value):
        """
        Set :math:`A[i, j] = \textrm{value}` directly.

        Note:
            Store zero elements **only** if ``store_zeros`` is ``True``.

        Warning:
            No out of bound check.

        See:
            :meth:`safe_put`.


        """
        if self.is_symmetric and i < j:
            raise IndexError('Write operation to upper triangle of symmetric matrix not allowed')

        cdef @index@ k, new_elem, last, col

        # Find element to be set (or removed)
        col = last = -1
        k = self.root[i]
        while k != -1:
            col = self.col[k]
            # TODO: check this
            if col >= j:
                break
            last = k
            k = self.link[k]

        # Store value
        if self.store_zeros or value != 0.0:
            if col == j:
                # element already exist
                self.val[k] = value
            else:
                # new element
                # find location for new element
                if self.free != -1:
                    # use element from the free chain
                    new_elem = self.free
                    self.free = self.link[new_elem]

                else:
                    # append new element to the end
                    new_elem = self.nnz

                # test if there is space for a new element
                if self.nnz == self.nalloc:
                    # we have to reallocate some space
                    self._realloc_expand()

                self.val[new_elem] = value

                self.col[new_elem] = j
                self.link[new_elem] = k

                if last == -1:
                    self.root[i] = new_elem
                else:
                    self.link[last] = new_elem

                self.nnz += 1

        else:
            # value == 0.0:
            # if element exists but we don't store zero elements
            # we need to "zeroify" this element
            if col == j:
                # relink row i
                if last == -1:
                    self.root[i] = self.link[k]
                else:
                    self.link[last] = self.link[k]

                # add element to free list
                self.link[k] = self.free
                self.free = k

                self.nnz -= 1


    cdef int safe_put(self, @index@ i, @index@ j, @type@ value)  except -1:
        """
        Set ``A[i, j] = value`` directly.

        Raises:
            IndexError: when index out of bound.

        """

        if i < 0 or i >= self.nrow or j < 0 or j >= self.ncol:
            raise IndexError('Indices out of range')
            return -1

        self.put(i, j, value)

        return 1

    ####################################################################################################################
    #                                            *** GET ***
    cdef @type@ at(self, @index@ i, @index@ j):
        """
        Return element ``(i, j)``.

        Warning:
            There is not out of bounds test.

        See:
            :meth:`safe_at`.


        """
        cdef @index@ k, t

        if self.is_symmetric and i < j:
            t = i; i = j; j = t

        k = self.root[i]

        while k != -1:
            # TODO: check this: we go over all elements in row i: is it really necessary?
            if self.col[k] == j:
                return self.val[k]
            k = self.link[k]

        return 0

    # EXPLICIT TYPE TESTS
{% if type == 'COMPLEX64_t' or type == 'COMPLEX128_t' %}
    cdef @type@ safe_at(self, @index@ i, @index@ j) except *:
{% else %}
    cdef @type@ safe_at(self, @index@ i, @index@ j) except? 1:
{% endif %}
        """
        Return element ``(i, j)`` but with check for out of bounds indices.

        Raises:
            IndexError: when index out of bound.


        """
        if not 0 <= i < self.nrow or not 0 <= j < self.ncol:
            raise IndexError("Index out of bounds")
{% if type != 'COMPLEX64_t' and type != 'COMPLEX128_t' %}
            return 1
{% endif %}
        return self.at(i, j)

    ####################################################################################################################
    # __setitem/__getitem__
    ####################################################################################################################
    def __setitem__(self, tuple key, value):
        """
        A[i, j] = value

        Raises:
            IndexError: when index out of bound.


        """
        if len(key) != 2:
            raise IndexError('Index tuple must be of length 2 (not %d)' % len(key))

        #cdef LLSparseMatrixView view

        ## test for direct access (i.e. both elements are integers)
        #if not PyInt_Check(<PyObject *>key[0]) or not PyInt_Check(<PyObject *>key[1]):
        #    # TODO: don't create temp object
        #    view = MakeLLSparseMatrixView(self, <PyObject *>key[0], <PyObject *>key[1])
        #    self.assign(view, value)

        #    del view
        #    return

        cdef @index@ i = key[0]
        cdef @index@ j = key[1]

        self.safe_put(i, j, value)

    def __getitem__(self, tuple key):
        """
        Return ``ll_mat[...]``.

        Args:
          key = (i,j): Must be a couple of values. Values can be:
                 * integers;
                 * slices;
                 * lists;
                 * numpy arrays

        Raises:
            IndexError: when index out of bound.

        Returns:
            If ``i`` and ``j`` are both integers, returns corresponding value ``ll_mat[i, j]``, otherwise
            returns a corresponding :class:`LLSparseMatrixView` view on the matrix.


        """
        if len(key) != 2:
            raise IndexError('Index tuple must be of length 2 (not %d)' % len(key))

        cdef LLSparseMatrixView_@index@_@type@ view

        # test for direct access (i.e. both elements are integers)
        if not PyInt_Check(<PyObject *>key[0]) or not PyInt_Check(<PyObject *>key[1]):
            view =  MakeLLSparseMatrixView_@index@_@type@(self, <PyObject *>key[0], <PyObject *>key[1])
            return view

        cdef @index@ i = key[0]
        cdef @index@ j = key[1]

        return self.safe_at(i, j)

    ####################################################################################################################
    # Set/Get list of elements
    ####################################################################################################################
    ####################################################################################################################
    #                                            *** SET ***
    def put_triplet(self, list index_i, list index_j, list val):
        """
        Assign triplet :math:`\{(i, j, \textrm{val})\}` values to the matrix..


        """
        cdef Py_ssize_t index_i_length = len(index_i)
        cdef Py_ssize_t index_j_length = len(index_j)
        cdef Py_ssize_t val_length = len(val)

        assert index_j_length == index_j_length == val_length, "All lists must be of equal length"

        cdef Py_ssize_t i
        cdef PyObject * elem

        for i from 0 <= i < index_i_length:
            self.safe_put(index_i[i], index_j[i], val[i])

    ####################################################################################################################
    #                                            *** GET ***
    cpdef object keys(self):
        """
        Return a list of tuples (i,j) of non-zero matrix entries.


        """
        cdef:
            #list list_container
            PyObject *list_p # the list that will hold the keys
            @index@ i, j, k
            Py_ssize_t pos = 0    # position in list

        if not self.is_symmetric:

            # create list
            list_p = PyList_New(self.nnz)
            if list_p == NULL:
                raise MemoryError()

            for i from 0 <= i < self.nrow:
                k = self.root[i]
                while k != -1:
                    j = self.col[k]
                    PyList_SET_ITEM(list_p, pos, Py_BuildValue("ii", i, j))
                    pos += 1
                    k = self.link[k]
        else:
            raise NotImplemented("keys() is not (yet) implemented for symmetrical LLSparseMatrix")

        return <object> list_p

    cpdef object values(self):
        """
        Return a list of the non-zero matrix entries.
        """
        cdef:
            PyObject *list_p   # the list that will hold the values
            @index@ i, k
            Py_ssize_t pos = 0        # position in list

        if not self.is_symmetric:
            list_p = PyList_New(self.nnz)
            if list_p == NULL:
                raise MemoryError()

            # EXPLICIT TYPE TESTS

            for i from 0<= i < self.nrow:
                k = self.root[i]
                while k != -1:
{% if type == 'INT32_t' %}
                    PyList_SET_ITEM(list_p, pos, Py_BuildValue("i", self.val[k]))
{% elif type == 'INT64_t' %}
                    PyList_SET_ITEM(list_p, pos, Py_BuildValue("l", self.val[k]))
{% elif type == 'UINT32_t' %}
                    PyList_SET_ITEM(list_p, pos, Py_BuildValue("I", self.val[k]))
{% elif type == 'UINT64_t' %}
                    PyList_SET_ITEM(list_p, pos, Py_BuildValue("k", self.val[k]))
{% elif type == 'FLOAT32_t' %}
                    PyList_SET_ITEM(list_p, pos, Py_BuildValue("f", self.val[k]))
{% elif type == 'FLOAT64_t' %}
                    PyList_SET_ITEM(list_p, pos, Py_BuildValue("d", self.val[k]))
{% elif type == 'COMPLEX64_t' %}
                    PyList_SET_ITEM(list_p, pos, PyComplex_FromDoubles(crealf(self.val[k]) , cimagf(self.val[k])))  # how to do this more efficiently?
{% elif type == 'COMPLEX128_t' %}
                    PyList_SET_ITEM(list_p, pos, PyComplex_FromDoubles(creal(self.val[k]), cimag(self.val[k])))
{% else %}
YOU HAVE TO DEFINE OR CAST YOUR NEW UNRECOGNIZED TYPE
{% endif %}

                    pos += 1
                    k = self.link[k]

        else:
            raise NotImplementedError("values() not (yet) implemented for symmetrical LLSparseMatrix")

        return <object> list_p


    cpdef object items(self):
        """
        Return a list of tuples (indices, value) of the non-zero matrix entries' keys and values.

        The indices are themselves tuples (i,j) of row and column values.

        """
        cdef:
            PyObject *list_p;     # the list that will hold the values
            @index@ i, j, k
            Py_ssize_t pos = 0         # position in list
            @type@ val

        list_p = PyList_New(self.nnz)
        if list_p == NULL:
            raise MemoryError()

        # EXPLICIT TYPE TESTS

        for i from 0 <= i < self.nrow:
            k = self.root[i]
            while k != -1:
                j = self.col[k]
                val = self.val[k]
{% if type == 'INT32_t' %}
                PyList_SET_ITEM(list_p, pos, Py_BuildValue("((ii)i)", i, j, self.val[k]))
{% elif type == 'INT64_t' %}
                PyList_SET_ITEM(list_p, pos, Py_BuildValue("((ii)l)", i, j, self.val[k]))
{% elif type == 'UINT32_t' %}
                PyList_SET_ITEM(list_p, pos, Py_BuildValue("((ii)I)", i, j, self.val[k]))
{% elif type == 'UINT64_t' %}
                PyList_SET_ITEM(list_p, pos, Py_BuildValue("((ii)k)", i, j, self.val[k]))
{% elif type == 'FLOAT32_t' %}
                PyList_SET_ITEM(list_p, pos, Py_BuildValue("((ii)f)", i, j, self.val[k]))
{% elif type == 'FLOAT64_t' %}
                PyList_SET_ITEM(list_p, pos, Py_BuildValue("((ii)d)", i, j, self.val[k]))
{% elif type == 'COMPLEX64_t' %}
                PyList_SET_ITEM(list_p, pos, Py_BuildValue("((ii)O)", i, j, PyComplex_FromDoubles(crealf(self.val[k]) , cimagf(self.val[k]))))
{% elif type == 'COMPLEX128_t' %}
                PyList_SET_ITEM(list_p, pos, Py_BuildValue("((ii)O)", i, j, PyComplex_FromDoubles(creal(self.val[k]) , cimag(self.val[k]))))
{% else %}
YOU HAVE TO DEFINE OR CAST YOUR NEW UNRECOGNIZED TYPE
{% endif %}

                pos += 1

                k = self.link[k]

        return <object> list_p

    cpdef find(self):
        """
        Return 3 NumPy arrays with the non-zero matrix entries: i-rows, j-cols, vals.
        """
        cdef cnp.npy_intp dmat[1]
        dmat[0] = <cnp.npy_intp> self.nnz

        # EXPLICIT TYPE TESTS

        cdef:

{% if index == 'INT32_t' %}
            cnp.ndarray[cnp.int32_t, ndim=1] a_row = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_INT32)
            cnp.ndarray[cnp.int32_t, ndim=1] a_col = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_INT32)
{% elif index == 'INT64_t' %}
            cnp.ndarray[cnp.int64_t, ndim=1] a_row = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_INT64)
            cnp.ndarray[cnp.int64_t, ndim=1] a_col = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_INT64)
{% else %}
YOU HAVE TO DEFINE WHAT HAPPENS WITH YOUR NEW INDEX TYPE
{% endif %}

{% if type == 'INT32_t' %}
            cnp.ndarray[cnp.int32_t, ndim=1] a_val = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_INT32)
{% elif type == 'INT64_t' %}
            cnp.ndarray[cnp.int64_t, ndim=1] a_val = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_INT64)
{% elif type == 'UINT32_t' %}
            cnp.ndarray[cnp.uint32_t, ndim=1] a_val  = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_UINT32)
{% elif type == 'UINT64_t' %}
            cnp.ndarray[cnp.uint64_t, ndim=1] a_val  = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_UINT64)
{% elif type == 'FLOAT32_t' %}
            cnp.ndarray[cnp.float32_t, ndim=1] a_val  = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_FLOAT32)
{% elif type == 'FLOAT64_t' %}
            cnp.ndarray[cnp.float64_t, ndim=1] a_val  = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_FLOAT64)
{% elif type == 'COMPLEX64_t' %}
            cnp.ndarray[cnp.complex64_t, ndim=1] a_val = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_COMPLEX64)
{% elif type == 'COMPLEX128_t' %}
            cnp.ndarray[cnp.complex128_t, ndim=1] a_val = cnp.PyArray_SimpleNew( 1, dmat, cnp.NPY_COMPLEX128)
{% else %}
YOU HAVE TO DEFINE OR CAST YOUR NEW UNRECOGNIZED TYPE
{% endif %}

            @index@   *pi, *pj;   # Intermediate pointers to matrix data
            @type@    *pv;
            @index@   i, k, elem;

        pi = <@index@ *> cnp.PyArray_DATA(a_row)
        pj = <@index@ *> cnp.PyArray_DATA(a_col)
        pv = <@type@ *> cnp.PyArray_DATA(a_val)

        elem = 0
        for i from 0 <= i < self.nrow:
            k = self.root[i]
            while k != -1:
                pi[ elem ] = i
                pj[ elem ] = self.col[k]
                pv[ elem ] = self.val[k]
                k = self.link[k]
                elem += 1

        return (a_row, a_col, a_val)


    ####################################################################################################################
    # Multiplication
    ####################################################################################################################
    def __mul__(self, B):
        """

        """
        # CASES
        if PyLLSparseMatrix_Check(B):
            #return multiply_two_ll_mat(self, B)
            raise NotImplementedError("Multiplication with this kind of object not implemented yet...")
        elif cnp.PyArray_Check(B):
            # test type
            assert are_mixed_types_compatible(@type|type2enum@, B.dtype), "Multiplication only allowed with a Numpy compatible type (%s)!" % cysparse_to_numpy_type(@type|type2enum@)
            #assert B.dtype == np.float64, "Multiplication only allowed with an array of C-doubles (numpy float64)!"

            if B.ndim == 2:
                #return multiply_ll_mat_with_numpy_ndarray(self, B)
                raise NotImplementedError("Multiplication with this kind of object not implemented yet...")
            elif B.ndim == 1:
                return multiply_ll_mat_with_numpy_vector_@index@_@type@(self, B)
            else:
                raise IndexError("Matrix dimensions must agree")
        else:
            raise NotImplementedError("Multiplication with this kind of object not implemented yet...")
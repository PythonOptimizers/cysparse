"""
Condensed Sparse Row (CSR) Format Matrices.


"""

from __future__ import print_function

from cysparse.sparse.s_mat cimport unexposed_value
from cysparse.types.cysparse_numpy_types import *

from cysparse.sparse.s_mat_matrices.s_mat_@index@_@type@ cimport ImmutableSparseMatrix_@index@_@type@, MutableSparseMatrix_@index@_@type@
from cysparse.sparse.ll_mat_matrices.ll_mat_@index@_@type@ cimport LLSparseMatrix_@index@_@type@
from cysparse.sparse.csc_mat_matrices.csc_mat_@index@_@type@ cimport CSCSparseMatrix_@index@_@type@

from cysparse.sparse.sparse_utils.generic.sort_indices_@index@ cimport sort_array_@index@

########################################################################################################################
# Cython, NumPy import/cimport
########################################################################################################################
from cpython.mem cimport PyMem_Malloc, PyMem_Realloc, PyMem_Free
from libc.stdlib cimport malloc,free, calloc
from libc.string cimport memcpy
from cpython cimport PyObject, Py_INCREF


cimport numpy as cnp
import numpy as np

cnp.import_array()


# TODO: These constants will be removed soon...
cdef int CSR_MAT_PPRINT_ROW_THRESH = 500       # row threshold for choosing print format
cdef int CSR_MAT_PPRINT_COL_THRESH = 20        # column threshold for choosing print format

cdef extern from "complex.h":
    float crealf(float complex z)
    float cimagf(float complex z)

    double creal(double complex z)
    double cimag(double complex z)

    long double creall(long double complex z)
    long double cimagl(long double complex z)

    double cabs(double complex z)
    float cabsf(float complex z)
    long double cabsl(long double complex z)

    double complex conj(double complex z)
    float complex  conjf (float complex z)
    long double complex conjl (long double complex z)

########################################################################################################################
# CySparse include
########################################################################################################################
# pxi files should come last (except for circular dependencies)

include "csr_mat_kernel/csr_mat_multiplication_by_numpy_vector_kernel_@index@_@type@.pxi"
include "csr_mat_helpers/csr_mat_multiplication_@index@_@type@.pxi"


cdef extern from "Python.h":
    # *** Types ***
    int PyInt_Check(PyObject *o)



cdef class CSRSparseMatrix_@index@_@type@(ImmutableSparseMatrix_@index@_@type@):
    """
    Compressed Sparse Row Format matrix.

    Note:
        This matrix can **not** be modified.

    """
    ####################################################################################################################
    # Init/Free/Memory
    ####################################################################################################################
    def __cinit__(self, **kwargs):

        self.__type = "CSRSparseMatrix"
        self.__type_name = "CSRSparseMatrix %s" % self.__index_and_type

    def __dealloc__(self):
        PyMem_Free(self.val)
        PyMem_Free(self.col)
        PyMem_Free(self.ind)

    def copy(self):
        """
        Return a (deep) copy of itself.

        Warning:
            Because we use memcpy and thus copy memory internally, we have to be careful to always update this method
            whenever the CSRSparseMatrix class changes.
        """
        # Warning: Because we use memcpy and thus copy memory internally, we have to be careful to always update this method
        # whenever the CSRSparseMatrix class changes...

        cdef CSRSparseMatrix_@index@_@type@ self_copy

        # we copy manually the C-arrays
        cdef:
            @type@ * val
            @index@ * col
            @index@ * ind
            @index@ nnz

        nnz = self.nnz

        self_copy = CSRSparseMatrix_@index@_@type@(control_object=unexposed_value, nrow=self.__nrow, ncol=self.__ncol, store_zeros=self.__store_zeros, is_symmetric=self.__is_symmetric)

        val = <@type@ *> PyMem_Malloc(nnz * sizeof(@type@))
        if not val:
            raise MemoryError()
        memcpy(val, self.val, nnz * sizeof(@type@))
        self_copy.val = val

        col = <@index@ *> PyMem_Malloc(nnz * sizeof(@index@))
        if not col:
            PyMem_Free(self_copy.val)
            raise MemoryError()
        memcpy(col, self.col, nnz * sizeof(@index@))
        self_copy.col = col

        ind = <@index@ *> PyMem_Malloc((self.__nrow + 1) * sizeof(@index@))
        if not ind:
            PyMem_Free(self_copy.val)
            PyMem_Free(self_copy.col)
            raise MemoryError()
        memcpy(ind, self.ind, (self.__nrow + 1) * sizeof(@index@))
        self_copy.ind = ind

        self_copy.__nnz = nnz

        return self_copy

    ####################################################################################################################
    # Column indices ordering
    ####################################################################################################################
    def are_column_indices_sorted(self):
        """
        Tell if column indices are sorted in augmenting order (ordered).


        """
        cdef @index@ i
        cdef @index@ col_index
        cdef @index@ col_index_stop

        if self.__col_indices_sorted_test_done:
            return self.__col_indices_sorted
        else:
            # do the test
            self.__col_indices_sorted_test_done = True
            # test each row
            for i from 0 <= i < self.nrow:
                col_index = self.ind[i]
                col_index_stop = self.ind[i+1] - 1

                self.__first_row_not_ordered = i

                while col_index < col_index_stop:
                    if self.col[col_index] > self.col[col_index + 1]:
                        self.__col_indices_sorted = False
                        return self.__col_indices_sorted
                    col_index += 1

        # column indices are ordered
        self.__first_row_not_ordered = self.nrow
        self.__col_indices_sorted = True
        return self.__col_indices_sorted

    cdef _order_column_indices(self):
        """
        Order column indices by ascending order.

        We use a simple insert sort. The idea is that the column indices aren't that much not ordered.
        """
        #  must be called to find first row not ordered
        if self.are_column_indices_sorted():
            return

        cdef @index@ i = self.__first_row_not_ordered
        cdef @index@ col_index
        cdef @index@ col_index_start
        cdef @index@ col_index_stop

        while i < self.nrow:
            col_index = self.ind[i]
            col_index_start = col_index
            col_index_stop = self.ind[i+1]

            while col_index < col_index_stop - 1:
                # detect if row is not ordered
                if self.col[col_index] > self.col[col_index + 1]:
                    # sort
                    # TODO: maybe use the column index for optimization?
                    sort_array_@index@(self.col, col_index_start, col_index_stop)
                    break
                else:
                    col_index += 1

            i += 1

    def order_column_indices(self):
        """
        Forces column indices to be ordered.
        """
        return self._order_column_indices()

    cdef _set_column_indices_ordered_is_true(self):
        """
        If you construct a CSR matrix and you know that its column indices **are** ordered, confirm it by calling this method.

        Warning:
            Be sure to know what you are doing because there is no control and we assume that the column indices are indeed sorted for
            almost all operations.
        """
        self.__col_indices_sorted_test_done = True
        self.__col_indices_sorted = True

    ####################################################################################################################
    # Set/Get items
    ####################################################################################################################
    ####################################################################################################################
    #                                            *** SET ***
    def __setitem__(self, tuple key, value):
        raise SyntaxError("Assign individual elements is not allowed")

    #                                            *** GET ***
    cdef at(self, @index@ i, @index@ j):
        """
        Direct access to element ``(i, j)``.

        Warning:
            There is not out of bounds test.

        See:
            :meth:`safe_at`.

        """
        cdef:
            @index@ k
            # for symmetric case
            @index@ real_i
            @index@ real_j

        # TODO: TEST!!!
        # code duplicated for optimization
        if self.__is_symmetric:
            if i < j:
                real_i = j
                real_j = i
            else:
                real_i = i
                real_j = j

            if self. __col_indices_sorted:
                for k from self.ind[real_i] <= k < self.ind[real_i+1]:
                    if real_j == self.col[k]:
                        return self.val[k]
                    elif real_j > self.col[k]:
                        break

            else:
                for k from self.ind[real_i] <= k < self.ind[real_i+1]:
                    if real_j == self.col[k]:
                        return self.val[k]

        else:
            if self. __col_indices_sorted:
                for k from self.ind[i] <= k < self.ind[i+1]:
                    if j == self.col[k]:
                        return self.val[k]
                    elif j > self.col[k]:
                        break

            else:
                for k from self.ind[i] <= k < self.ind[i+1]:
                    if j == self.col[k]:
                        return self.val[k]

        return 0.0

    # EXPLICIT TYPE TESTS
{% if type in complex_list %}
    # this is needed as for the complex type, Cython's compiler crashes...
    cdef @type@ safe_at(self, @index@ i, @index@ j) except *:
{% else %}
    cdef @type@ safe_at(self, @index@ i, @index@ j) except? 2:
{% endif %}
        """
        Return element ``(i, j)`` but with check for out of bounds indices.

        Raises:
            IndexError: when index out of bound.

        """
        if not 0 <= i < self.nrow or not 0 <= j < self.ncol:
            raise IndexError("Index out of bounds")

        return self.at(i, j)

    def __getitem__(self, tuple key):
        """
        Return ``csr_mat[i, j]``.

        Args:
          key = (i,j): Must be a couple of integers.

        Raises:
            IndexError: when index out of bound.

        Returns:
            ``csr_mat[i, j]``.
        """
        if len(key) != 2:
            raise IndexError('Index tuple must be of length 2 (not %d)' % len(key))

        if not PyInt_Check(<PyObject *>key[0]) or not PyInt_Check(<PyObject *>key[1]):
            raise IndexError("Only integer indices are allowed")

        cdef @index@ i = key[0]
        cdef @index@ j = key[1]

        return self.safe_at(i, j)

    ####################################################################################################################
    # Common operations
    ####################################################################################################################
    def find(self):
        """
        Return 3 NumPy arrays with the non-zero matrix entries: i-rows, j-cols, vals.
        """
        cdef cnp.npy_intp dmat[1]
        dmat[0] = <cnp.npy_intp> self.__nnz

        # EXPLICIT TYPE TESTS

        cdef:
            cnp.ndarray[cnp.@index|cysparse_type_to_numpy_c_type@, ndim=1] a_row = cnp.PyArray_SimpleNew( 1, dmat, cnp.@index|cysparse_type_to_numpy_enum_type@)
            cnp.ndarray[cnp.@index|cysparse_type_to_numpy_c_type@, ndim=1] a_col = cnp.PyArray_SimpleNew( 1, dmat, cnp.@index|cysparse_type_to_numpy_enum_type@)
            cnp.ndarray[cnp.@type|cysparse_type_to_numpy_c_type@, ndim=1] a_val = cnp.PyArray_SimpleNew( 1, dmat, cnp.@type|cysparse_type_to_numpy_enum_type@)

            # Intermediate pointers to matrix data
            @index@   *pi
            @index@   *pj
            @type@    *pv
            @index@   i, k, elem

        pi = <@index@ *> cnp.PyArray_DATA(a_row)
        pj = <@index@ *> cnp.PyArray_DATA(a_col)
        pv = <@type@ *> cnp.PyArray_DATA(a_val)

        elem = 0
        for i from 0 <= i < self.__nrow:
            for k from self.ind[i] <= k < self.ind[i+1]:
                pi[ elem ] = i
                pj[ elem ] = self.col[k]
                pv[ elem ] = self.val[k]
                elem += 1

        return (a_row, a_col, a_val)

    def diag(self, k = 0):
        """
        Return the :math:`k^\textrm{th}` diagonal.

        """
        if not (-self.__nrow + 1 <= k <= self.__ncol -1):
            raise IndexError("Wrong diagonal number (%d <= k <= %d)" % (-self.__nrow + 1, self.__ncol -1))

        cdef @index@ diag_size

        if k == 0:
            diag_size = min(self.__nrow, self.__ncol)
        elif k > 0:
            diag_size = min(self.__nrow, self.__ncol - k)
        else:
            diag_size = min(self.__nrow+k, self.__ncol)

        assert diag_size > 0, "Something is wrong with the diagonal size"

        # create NumPy array
        cdef cnp.npy_intp dmat[1]
        dmat[0] = <cnp.npy_intp> diag_size

        cdef:
            cnp.ndarray[cnp.@type|cysparse_type_to_numpy_c_type@, ndim=1] diag = cnp.PyArray_SimpleNew( 1, dmat, cnp.@type|cysparse_type_to_numpy_enum_type@)
            @type@    *pv
            @index@   i, k_

        pv = <@type@ *> cnp.PyArray_DATA(diag)

        # init NumPy array
        for i from 0 <= i < diag_size:
{% if type in integer_list %}
            pv[i] = 0
{% elif type in real_list %}
            pv[i] = 0.0
{% elif type in complex_list %}
            pv[i] = 0.0 + 0.0j
{% else %}
YOU HAVE TO EXPLICITY CAST YOUR TYPE
{% endif %}

        if k >= 0:
            for i from 0 <= i < self.__nrow:
                for k_ from self.ind[i] <= k_ < self.ind[i+1]:
                    if i + k == self.col[k_]:
                        pv[i] = self.val[k_]

        else:  #  k < 0
            for i from 0 <= i < self.__nrow:
                for k_ from self.ind[i] <= k_ < self.ind[i+1]:
                    j = self.col[k_]
                    if i + k == j:
                        pv[j] = self.val[k_]

        return diag

    def to_ndarray(self):
        """
        Return the matrix in the form of a :program:`NumPy` ``ndarray``.

        """
        # EXPLICIT TYPE TESTS
        cdef:
            cnp.ndarray[cnp.@type|cysparse_type_to_numpy_c_type@, ndim=2] np_ndarray
            @index@ i, k
            @type@ [:,:] np_memview

        np_ndarray = np.zeros((self.__nrow, self.__ncol), dtype=np.@type|cysparse_type_to_numpy_type@, order='C')
        np_memview = np_ndarray

        for i from 0 <= i < self.__nrow:
            for k from self.ind[i] <= k < self.ind[i+1]:
                np_memview[i, self.col[k]] = self.val[k]

        return np_ndarray

    ####################################################################################################################
    # Multiplication
    ####################################################################################################################
    def matvec(self, b):
        """
        Return :math:`A * b`.
        """
        return multiply_csr_mat_with_numpy_vector_@index@_@type@(self, b)

    def matvec_transp(self, b):
        """
        Return :math:`A^t * b`.
        """
        return multiply_transposed_csr_mat_with_numpy_vector_@index@_@type@(self, b)

{% if type in complex_list %}
    def matvec_htransp(self, b):
        """
        Return :math:`A^h * b`.
        """
        assert are_mixed_types_compatible(@type|type2enum@, b.dtype), "Multiplication only allowed with a Numpy compatible type (%s)!" % cysparse_to_numpy_type(@type|type2enum@)
        return multiply_conjugate_transposed_csr_mat_with_numpy_vector_@index@_@type@(self, b)

    def matvec_conj(self, b):
        """
        Return :math:`\textrm{conj}(A) * b`.
        """
        assert are_mixed_types_compatible(@type|type2enum@, b.dtype), "Multiplication only allowed with a Numpy compatible type (%s)!" % cysparse_to_numpy_type(@type|type2enum@)
        return multiply_conjugated_csr_mat_with_numpy_vector_@index@_@type@(self, b)
{% endif %}

    def matdot(self, B):
        raise NotImplementedError("Multiplication with this kind of object not allowed")

    def matdot_transp(self, B):
        raise NotImplementedError("Multiplication with this kind of object not allowed")

    def __mul__(self, other):

        # test if implemented
        if isinstance(other, (MutableSparseMatrix_@index@_@type@, ImmutableSparseMatrix_@index@_@type@)):
            pass
        else:
            raise NotImplemented("Multiplication not (yet) allowed")

        # CASES
        if isinstance(other, CSCSparseMatrix_@index@_@type@):
            return multiply_csr_mat_by_csc_mat_@index@_@type@(self, other)
        else:
            raise NotImplemented("Multiplication not (yet) allowed")

    ####################################################################################################################
    # String representations
    ####################################################################################################################
    def __repr__(self):
        s = "CSRSparseMatrix of size %d by %d with %d non zero values" % (self.nrow, self.ncol, self.nnz)
        return s

    def print_to(self, OUT, width=9, print_big_matrices=False, transposed=False):
        """
        Print content of matrix to output stream.

        Args:
            OUT: Output stream that print (Python3) can print to.
        """
        # EXPLICIT TYPE TESTS
        # TODO: adapt to any numbers... and allow for additional parameters to control the output
        cdef @index@ i, k, first = 1;

        cdef @type@ *mat
        cdef @index@ j
        cdef @type@ val

        print(self._matrix_description_before_printing(), file=OUT)
        #print('CSRSparseMatrix ([%d,%d]):' % (self.nrow, self.ncol), file=OUT)

        if not self.nnz:
            return

        if self.nrow <= CSR_MAT_PPRINT_COL_THRESH and self.ncol <= CSR_MAT_PPRINT_ROW_THRESH:
            # create linear vector presentation
            # TODO: put in a method of its own
            mat = <@type@ *> PyMem_Malloc(self.nrow * self.ncol * sizeof(@type@))

            if not mat:
                raise MemoryError()

            # creation of temp matrix
            for i from 0 <= i < self.nrow:
                for j from 0 <= j < self.ncol:
{% if type in integer_list %}
                    mat[i* self.ncol + j] = 0
{% elif type in complex_list %}
                    mat[i* self.ncol + j] = 0.0 + 0.0j
{% else %}
                    mat[i* self.ncol + j] = 0.0
{% endif %}

                k = self.ind[i]
                while k < self.ind[i+1]:
                    mat[(i*self.ncol)+self.col[k]] = self.val[k]
                    k += 1

            for i from 0 <= i < self.nrow:
                for j from 0 <= j < self.ncol:
                    val = mat[(i*self.ncol)+j]
{% if type not in INTEGER_ELEMENT_TYPES %}
                    print('{:{width}.6f} '.format(val, width=width), end='', file=OUT)
{% else %}
                    print('{0:{width}d} '.format(val, width=width), end='', file=OUT)
{% endif %}
                print(file=OUT)

            PyMem_Free(mat)

        else:
            print('Matrix too big to print out', file=OUT)

    ####################################################################################################################
    # Internal arrays
    ####################################################################################################################
    # TODO: test, test, test!
    def get_c_pointers(self):
        """
        Return C pointers to internal arrays.

        Returns:
            Triple `(ind, col, val)`.

        Warning:
            The returned values can only be used by C-extensions.
        """
        cdef:
            PyObject * ind_obj = <PyObject *> self.ind
            PyObject * col_obj = <PyObject *> self.col
            PyObject * val_obj = <PyObject *> self.val

        return <object>ind_obj, <object>col_obj, <object>val_obj

    def get_numpy_arrays(self):
        """
        Return :program:`NumPy` arrays equivalent to internal C-arrays.

        Note:
            No copy is made, i.e. the :program:`NumPy` arrays have direct access to the internal C-arrays. Change the
            former and you change the latter (which shouldn't happen unless you **really** know what you are doing).
        """
        cdef:
            cnp.npy_intp dim[1]

        # ind
        dim[0] = self.nrow + 1
        ind_numpy_array = cnp.PyArray_SimpleNewFromData(1, dim, cnp.@index|cysparse_type_to_numpy_enum_type@, <@index@ *>self.ind)

        # col
        dim[0] = self.nnz
        col_numpy_array = cnp.PyArray_SimpleNewFromData(1, dim, cnp.@index|cysparse_type_to_numpy_enum_type@, <@index@ *>self.col)

        # val
        dim[0] = self.nnz
        val_numpy_array = cnp.PyArray_SimpleNewFromData(1, dim, cnp.@type|cysparse_type_to_numpy_enum_type@, <@type@ *>self.val)


        return ind_numpy_array, col_numpy_array, val_numpy_array

    ####################################################################################################################
    # DEBUG
    ####################################################################################################################
    def debug_print(self):
        cdef @index@ i
        print("ind:")
        for i from 0 <= i < self.nrow + 1:
            print(self.ind[i], end=' ', sep=' ')
        print()

        print("col:")
        for i from 0 <= i < self.nnz:
            print(self.col[i], end=' ', sep=' ')
        print()

        print("val:")
        for i from 0 <= i < self.nnz:
            print(self.val[i], end=' == ', sep=' == ')
        print()

        if self.is_complex:
            for i from 0 <= i < self.nnz:
                print(self.ival[i], end=' == ', sep=' == ')
            print()

    def set_col(self, @index@ i, @index@ val):
        self.col[i] = val

########################################################################################################################
# Factory methods
########################################################################################################################
cdef MakeCSRSparseMatrix_@index@_@type@(@index@ nrow, @index@ ncol, @index@ nnz, @index@ * ind, @index@ * col, @type@ * val, bint is_symmetric, bint store_zeros):
    """
    Construct a CSRSparseMatrix object.

    Args:
        nrow (@index@): Number of rows.
        ncol (@index@): Number of columns.
        nnz (@index@): Number of non-zeros.
        ind (@index@ *): C-array with column indices pointers.
        col  (@index@ *): C-array with column indices.
        val  (@type@ *): C-array with values.
        is_symmetric (boolean): Is matrix symmetrix or not?
    """

    csr_mat = CSRSparseMatrix_@index@_@type@(control_object=unexposed_value, nrow=nrow, ncol=ncol, nnz=nnz, is_symmetric=is_symmetric, store_zeros=store_zeros)

    csr_mat.val = val
    csr_mat.ind = ind
    csr_mat.col = col

    return csr_mat

########################################################################################################################
# Multiplication functions
########################################################################################################################
# TODO: put in helpers...
cdef LLSparseMatrix_@index@_@type@ multiply_csr_mat_by_csc_mat_@index@_@type@(CSRSparseMatrix_@index@_@type@ A, CSCSparseMatrix_@index@_@type@ B):

    if A.is_complex or B.is_complex:
        raise NotImplemented("This operation is not (yet) implemented for complex matrices")

    # TODO: take into account if matrix A or B has its column indices ordered or not...
    # test dimensions
    cdef @index@ A_nrow = A.nrow
    cdef @index@ A_ncol = A.ncol

    cdef @index@ B_nrow = B.nrow
    cdef @index@ B_ncol = B.ncol

    if A_ncol != B_nrow:
        raise IndexError("Matrix dimensions must agree ([%d, %d] * [%d, %d])" % (A_nrow, A_ncol, B_nrow, B_ncol))

    cdef @index@ C_nrow = A_nrow
    cdef @index@ C_ncol = B_ncol

    cdef bint store_zeros = A.store_zeros and B.store_zeros
    # TODO: what strategy to implement?
    cdef @index@ size_hint = A.nnz

    # TODO: maybe use MakeLLSparseMatrix and fix circular dependencies...
    C = LLSparseMatrix_@index@_@type@(control_object=unexposed_value, nrow=C_nrow, ncol=C_ncol, size_hint=size_hint, store_zeros=store_zeros)

    # CASES
    if not A.__is_symmetric and not B.__is_symmetric:
        pass
    else:
        raise NotImplemented("Multiplication with symmetric matrices is not implemented yet")

    # NON OPTIMIZED MULTIPLICATION
    # TODO: what do we do? Column indices are NOT necessarily sorted...
    cdef:
        @index@ i, j, k
        @type@ sum

    # don't keep zeros, no matter what
    cdef bint old_store_zeros = store_zeros
    C.store_zeros = 0

    for i from 0 <= i < C_nrow:
        for j from 0 <= j < C_ncol:
{% if type in integer_list %}
            sum = 0
{% elif type in complex_list %}
            sum = 0.0 + 0.0j
{% else %}
            sum = 0.0
{% endif %}

            for k from 0 <= k < A_ncol:
                sum += (A[i, k] * B[k, j])

            C.put(i, j, sum)

    C.store_zeros = old_store_zeros

    return C
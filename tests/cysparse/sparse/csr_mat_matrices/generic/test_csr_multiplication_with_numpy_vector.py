#!/usr/bin/env python

"""
This file tests the multiplication of an :class:`CSRSparseMatrix` matricix with a :program:`NumPy` vector.

We test **all** types and the symmetric and general cases. We also test strided vectors.
We only use the real parts of complex numbers.


     If this is a python script (.py), it has been automatically generated by the 'generate_code.py' script.

"""
from cysparse.sparse.ll_mat import *
from cysparse.types.cysparse_types import *
import numpy as np

import unittest

import sys

########################################################################################################################
# Helpers
########################################################################################################################
def construct_sym_sparse_matrix(A, n, nbr_elements):
    for i in xrange(nbr_elements):
        k = i % n
        p = (i % 2 + 1) % n
        if k >= p:
            A[k, p] = i / 3
        else:
            A[p, k] = i / 3

def construct_sparse_matrix(A, m, n, nbr_elements):
    for i in xrange(nbr_elements):
        k = i % n
        p = (i % 2 + 1) % m
        A[p, k] = i / 3

########################################################################################################################
# Tests
########################################################################################################################
class CySparseCSRMultiplicationWithANumpyVectorBaseTestCase(unittest.TestCase):
    def setUp(self):
        pass

class CySparseCSRMultiplicationWithANumpyVectorTestCase(CySparseCSRMultiplicationWithANumpyVectorBaseTestCase):
    """
    Basic case: ``y = A * x`` with ``A`` **non** symmetric and ``x`` and ``y`` without strides.
    """
    def setUp(self):
        self.nbr_of_elements = 10
        self.nrow = 80
        self.ncol = 100


  
  
        self.l_1_1 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=INT32_T)
        construct_sparse_matrix(self.l_1_1, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_1_1_csr = self.l_1_1.to_csr()
  
        self.l_1_2 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=INT64_T)
        construct_sparse_matrix(self.l_1_2, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_1_2_csr = self.l_1_2.to_csr()
  
        self.l_1_3 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT32_T)
        construct_sparse_matrix(self.l_1_3, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_1_3_csr = self.l_1_3.to_csr()
  
        self.l_1_4 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT64_T)
        construct_sparse_matrix(self.l_1_4, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_1_4_csr = self.l_1_4.to_csr()
  
        self.l_1_5 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT128_T)
        construct_sparse_matrix(self.l_1_5, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_1_5_csr = self.l_1_5.to_csr()
  
        self.l_1_6 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX64_T)
        construct_sparse_matrix(self.l_1_6, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_1_6_csr = self.l_1_6.to_csr()
  
        self.l_1_7 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX128_T)
        construct_sparse_matrix(self.l_1_7, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_1_7_csr = self.l_1_7.to_csr()
  
        self.l_1_8 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX256_T)
        construct_sparse_matrix(self.l_1_8, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_1_8_csr = self.l_1_8.to_csr()
  

  
  
        self.l_2_1 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=INT32_T)
        construct_sparse_matrix(self.l_2_1, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_2_1_csr = self.l_2_1.to_csr()
  
        self.l_2_2 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=INT64_T)
        construct_sparse_matrix(self.l_2_2, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_2_2_csr = self.l_2_2.to_csr()
  
        self.l_2_3 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT32_T)
        construct_sparse_matrix(self.l_2_3, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_2_3_csr = self.l_2_3.to_csr()
  
        self.l_2_4 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT64_T)
        construct_sparse_matrix(self.l_2_4, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_2_4_csr = self.l_2_4.to_csr()
  
        self.l_2_5 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT128_T)
        construct_sparse_matrix(self.l_2_5, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_2_5_csr = self.l_2_5.to_csr()
  
        self.l_2_6 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX64_T)
        construct_sparse_matrix(self.l_2_6, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_2_6_csr = self.l_2_6.to_csr()
  
        self.l_2_7 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX128_T)
        construct_sparse_matrix(self.l_2_7, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_2_7_csr = self.l_2_7.to_csr()
  
        self.l_2_8 = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX256_T)
        construct_sparse_matrix(self.l_2_8, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_2_8_csr = self.l_2_8.to_csr()
  



        self.x_INT32_t = np.ones(self.ncol, dtype=np.int32)

        self.x_INT64_t = np.ones(self.ncol, dtype=np.int64)

        self.x_FLOAT32_t = np.ones(self.ncol, dtype=np.float32)

        self.x_FLOAT64_t = np.ones(self.ncol, dtype=np.float64)

        self.x_FLOAT128_t = np.ones(self.ncol, dtype=np.float128)

        self.x_COMPLEX64_t = np.ones(self.ncol, dtype=np.complex64)

        self.x_COMPLEX128_t = np.ones(self.ncol, dtype=np.complex128)

        self.x_COMPLEX256_t = np.ones(self.ncol, dtype=np.complex256)


    def test_simple_multiplication_one_by_one(self):

  
  
        l_y = self.l_1_1.matvec(self.x_INT32_t)
        csr_y = self.l_1_1_csr.matvec(self.x_INT32_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_2.matvec(self.x_INT64_t)
        csr_y = self.l_1_2_csr.matvec(self.x_INT64_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_3.matvec(self.x_FLOAT32_t)
        csr_y = self.l_1_3_csr.matvec(self.x_FLOAT32_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_4.matvec(self.x_FLOAT64_t)
        csr_y = self.l_1_4_csr.matvec(self.x_FLOAT64_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_5.matvec(self.x_FLOAT128_t)
        csr_y = self.l_1_5_csr.matvec(self.x_FLOAT128_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_6.matvec(self.x_COMPLEX64_t)
        csr_y = self.l_1_6_csr.matvec(self.x_COMPLEX64_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_7.matvec(self.x_COMPLEX128_t)
        csr_y = self.l_1_7_csr.matvec(self.x_COMPLEX128_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_8.matvec(self.x_COMPLEX256_t)
        csr_y = self.l_1_8_csr.matvec(self.x_COMPLEX256_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  

  
  
        l_y = self.l_2_1.matvec(self.x_INT32_t)
        csr_y = self.l_2_1_csr.matvec(self.x_INT32_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_2.matvec(self.x_INT64_t)
        csr_y = self.l_2_2_csr.matvec(self.x_INT64_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_3.matvec(self.x_FLOAT32_t)
        csr_y = self.l_2_3_csr.matvec(self.x_FLOAT32_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_4.matvec(self.x_FLOAT64_t)
        csr_y = self.l_2_4_csr.matvec(self.x_FLOAT64_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_5.matvec(self.x_FLOAT128_t)
        csr_y = self.l_2_5_csr.matvec(self.x_FLOAT128_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_6.matvec(self.x_COMPLEX64_t)
        csr_y = self.l_2_6_csr.matvec(self.x_COMPLEX64_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_7.matvec(self.x_COMPLEX128_t)
        csr_y = self.l_2_7_csr.matvec(self.x_COMPLEX128_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_8.matvec(self.x_COMPLEX256_t)
        csr_y = self.l_2_8_csr.matvec(self.x_COMPLEX256_t)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  



class CySparseSymCSRMultiplicationWithANumpyVectorTestCase(CySparseCSRMultiplicationWithANumpyVectorBaseTestCase):
    """
    Basic case: ``y = A * x`` with ``A`` symmetric and ``x`` and ``y`` without strides.
    """
    def setUp(self):
        self.nbr_of_elements = 10
        self.size = 100

  
  
        self.l_1_1 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=INT32_T)
        construct_sym_sparse_matrix(self.l_1_1, self.size, self.nbr_of_elements)

        self.l_1_1_csr = self.l_1_1.to_csr()
  
        self.l_1_2 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=INT64_T)
        construct_sym_sparse_matrix(self.l_1_2, self.size, self.nbr_of_elements)

        self.l_1_2_csr = self.l_1_2.to_csr()
  
        self.l_1_3 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT32_T)
        construct_sym_sparse_matrix(self.l_1_3, self.size, self.nbr_of_elements)

        self.l_1_3_csr = self.l_1_3.to_csr()
  
        self.l_1_4 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT64_T)
        construct_sym_sparse_matrix(self.l_1_4, self.size, self.nbr_of_elements)

        self.l_1_4_csr = self.l_1_4.to_csr()
  
        self.l_1_5 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT128_T)
        construct_sym_sparse_matrix(self.l_1_5, self.size, self.nbr_of_elements)

        self.l_1_5_csr = self.l_1_5.to_csr()
  
        self.l_1_6 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX64_T)
        construct_sym_sparse_matrix(self.l_1_6, self.size, self.nbr_of_elements)

        self.l_1_6_csr = self.l_1_6.to_csr()
  
        self.l_1_7 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX128_T)
        construct_sym_sparse_matrix(self.l_1_7, self.size, self.nbr_of_elements)

        self.l_1_7_csr = self.l_1_7.to_csr()
  
        self.l_1_8 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX256_T)
        construct_sym_sparse_matrix(self.l_1_8, self.size, self.nbr_of_elements)

        self.l_1_8_csr = self.l_1_8.to_csr()
  

  
  
        self.l_2_1 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=INT32_T)
        construct_sym_sparse_matrix(self.l_2_1, self.size, self.nbr_of_elements)

        self.l_2_1_csr = self.l_2_1.to_csr()
  
        self.l_2_2 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=INT64_T)
        construct_sym_sparse_matrix(self.l_2_2, self.size, self.nbr_of_elements)

        self.l_2_2_csr = self.l_2_2.to_csr()
  
        self.l_2_3 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT32_T)
        construct_sym_sparse_matrix(self.l_2_3, self.size, self.nbr_of_elements)

        self.l_2_3_csr = self.l_2_3.to_csr()
  
        self.l_2_4 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT64_T)
        construct_sym_sparse_matrix(self.l_2_4, self.size, self.nbr_of_elements)

        self.l_2_4_csr = self.l_2_4.to_csr()
  
        self.l_2_5 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT128_T)
        construct_sym_sparse_matrix(self.l_2_5, self.size, self.nbr_of_elements)

        self.l_2_5_csr = self.l_2_5.to_csr()
  
        self.l_2_6 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX64_T)
        construct_sym_sparse_matrix(self.l_2_6, self.size, self.nbr_of_elements)

        self.l_2_6_csr = self.l_2_6.to_csr()
  
        self.l_2_7 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX128_T)
        construct_sym_sparse_matrix(self.l_2_7, self.size, self.nbr_of_elements)

        self.l_2_7_csr = self.l_2_7.to_csr()
  
        self.l_2_8 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX256_T)
        construct_sym_sparse_matrix(self.l_2_8, self.size, self.nbr_of_elements)

        self.l_2_8_csr = self.l_2_8.to_csr()
  



        self.x_INT32_t = np.ones(self.size, dtype=np.int32)

        self.x_INT64_t = np.ones(self.size, dtype=np.int64)

        self.x_FLOAT32_t = np.ones(self.size, dtype=np.float32)

        self.x_FLOAT64_t = np.ones(self.size, dtype=np.float64)

        self.x_FLOAT128_t = np.ones(self.size, dtype=np.float128)

        self.x_COMPLEX64_t = np.ones(self.size, dtype=np.complex64)

        self.x_COMPLEX128_t = np.ones(self.size, dtype=np.complex128)

        self.x_COMPLEX256_t = np.ones(self.size, dtype=np.complex256)


    def test_simple_multiplication_one_by_one(self):

  
  
        l_y = self.l_1_1.matvec(self.x_INT32_t)
        csr_y = self.l_1_1_csr.matvec(self.x_INT32_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_2.matvec(self.x_INT64_t)
        csr_y = self.l_1_2_csr.matvec(self.x_INT64_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_3.matvec(self.x_FLOAT32_t)
        csr_y = self.l_1_3_csr.matvec(self.x_FLOAT32_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_4.matvec(self.x_FLOAT64_t)
        csr_y = self.l_1_4_csr.matvec(self.x_FLOAT64_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_5.matvec(self.x_FLOAT128_t)
        csr_y = self.l_1_5_csr.matvec(self.x_FLOAT128_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_6.matvec(self.x_COMPLEX64_t)
        csr_y = self.l_1_6_csr.matvec(self.x_COMPLEX64_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_7.matvec(self.x_COMPLEX128_t)
        csr_y = self.l_1_7_csr.matvec(self.x_COMPLEX128_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_8.matvec(self.x_COMPLEX256_t)
        csr_y = self.l_1_8_csr.matvec(self.x_COMPLEX256_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  

  
  
        l_y = self.l_2_1.matvec(self.x_INT32_t)
        csr_y = self.l_2_1_csr.matvec(self.x_INT32_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_2.matvec(self.x_INT64_t)
        csr_y = self.l_2_2_csr.matvec(self.x_INT64_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_3.matvec(self.x_FLOAT32_t)
        csr_y = self.l_2_3_csr.matvec(self.x_FLOAT32_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_4.matvec(self.x_FLOAT64_t)
        csr_y = self.l_2_4_csr.matvec(self.x_FLOAT64_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_5.matvec(self.x_FLOAT128_t)
        csr_y = self.l_2_5_csr.matvec(self.x_FLOAT128_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_6.matvec(self.x_COMPLEX64_t)
        csr_y = self.l_2_6_csr.matvec(self.x_COMPLEX64_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_7.matvec(self.x_COMPLEX128_t)
        csr_y = self.l_2_7_csr.matvec(self.x_COMPLEX128_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_8.matvec(self.x_COMPLEX256_t)
        csr_y = self.l_2_8_csr.matvec(self.x_COMPLEX256_t)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  



class CySparseCSRMultiplicationWithAStridedNumpyVectorTestCase(CySparseCSRMultiplicationWithANumpyVectorBaseTestCase):
    """
    Basic case: ``y = A * x`` with ``A`` **symmetric** and ``x`` **with** strides.
    """
    def setUp(self):
        self.nbr_of_elements = 10
        self.size = 100

        self.stride_factor = 10


  
  
        self.l_1_1 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=INT32_T)
        construct_sym_sparse_matrix(self.l_1_1, self.size, self.nbr_of_elements)

        self.l_1_1_csr = self.l_1_1.to_csr()
  
        self.l_1_2 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=INT64_T)
        construct_sym_sparse_matrix(self.l_1_2, self.size, self.nbr_of_elements)

        self.l_1_2_csr = self.l_1_2.to_csr()
  
        self.l_1_3 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT32_T)
        construct_sym_sparse_matrix(self.l_1_3, self.size, self.nbr_of_elements)

        self.l_1_3_csr = self.l_1_3.to_csr()
  
        self.l_1_4 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT64_T)
        construct_sym_sparse_matrix(self.l_1_4, self.size, self.nbr_of_elements)

        self.l_1_4_csr = self.l_1_4.to_csr()
  
        self.l_1_5 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT128_T)
        construct_sym_sparse_matrix(self.l_1_5, self.size, self.nbr_of_elements)

        self.l_1_5_csr = self.l_1_5.to_csr()
  
        self.l_1_6 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX64_T)
        construct_sym_sparse_matrix(self.l_1_6, self.size, self.nbr_of_elements)

        self.l_1_6_csr = self.l_1_6.to_csr()
  
        self.l_1_7 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX128_T)
        construct_sym_sparse_matrix(self.l_1_7, self.size, self.nbr_of_elements)

        self.l_1_7_csr = self.l_1_7.to_csr()
  
        self.l_1_8 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX256_T)
        construct_sym_sparse_matrix(self.l_1_8, self.size, self.nbr_of_elements)

        self.l_1_8_csr = self.l_1_8.to_csr()
  

  
  
        self.l_2_1 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=INT32_T)
        construct_sym_sparse_matrix(self.l_2_1, self.size, self.nbr_of_elements)

        self.l_2_1_csr = self.l_2_1.to_csr()
  
        self.l_2_2 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=INT64_T)
        construct_sym_sparse_matrix(self.l_2_2, self.size, self.nbr_of_elements)

        self.l_2_2_csr = self.l_2_2.to_csr()
  
        self.l_2_3 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT32_T)
        construct_sym_sparse_matrix(self.l_2_3, self.size, self.nbr_of_elements)

        self.l_2_3_csr = self.l_2_3.to_csr()
  
        self.l_2_4 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT64_T)
        construct_sym_sparse_matrix(self.l_2_4, self.size, self.nbr_of_elements)

        self.l_2_4_csr = self.l_2_4.to_csr()
  
        self.l_2_5 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT128_T)
        construct_sym_sparse_matrix(self.l_2_5, self.size, self.nbr_of_elements)

        self.l_2_5_csr = self.l_2_5.to_csr()
  
        self.l_2_6 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX64_T)
        construct_sym_sparse_matrix(self.l_2_6, self.size, self.nbr_of_elements)

        self.l_2_6_csr = self.l_2_6.to_csr()
  
        self.l_2_7 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX128_T)
        construct_sym_sparse_matrix(self.l_2_7, self.size, self.nbr_of_elements)

        self.l_2_7_csr = self.l_2_7.to_csr()
  
        self.l_2_8 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX256_T)
        construct_sym_sparse_matrix(self.l_2_8, self.size, self.nbr_of_elements)

        self.l_2_8_csr = self.l_2_8.to_csr()
  



        self.x_INT32_t = np.ones(self.size, dtype=np.int32)
        self.x_strided_INT32_t = np.empty(self.size * self.stride_factor, dtype=np.int32)
        self.x_strided_INT32_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_INT32_t[i * self.stride_factor] = self.x_INT32_t[i]

        self.x_INT64_t = np.ones(self.size, dtype=np.int64)
        self.x_strided_INT64_t = np.empty(self.size * self.stride_factor, dtype=np.int64)
        self.x_strided_INT64_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_INT64_t[i * self.stride_factor] = self.x_INT64_t[i]

        self.x_FLOAT32_t = np.ones(self.size, dtype=np.float32)
        self.x_strided_FLOAT32_t = np.empty(self.size * self.stride_factor, dtype=np.float32)
        self.x_strided_FLOAT32_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_FLOAT32_t[i * self.stride_factor] = self.x_FLOAT32_t[i]

        self.x_FLOAT64_t = np.ones(self.size, dtype=np.float64)
        self.x_strided_FLOAT64_t = np.empty(self.size * self.stride_factor, dtype=np.float64)
        self.x_strided_FLOAT64_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_FLOAT64_t[i * self.stride_factor] = self.x_FLOAT64_t[i]

        self.x_FLOAT128_t = np.ones(self.size, dtype=np.float128)
        self.x_strided_FLOAT128_t = np.empty(self.size * self.stride_factor, dtype=np.float128)
        self.x_strided_FLOAT128_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_FLOAT128_t[i * self.stride_factor] = self.x_FLOAT128_t[i]

        self.x_COMPLEX64_t = np.ones(self.size, dtype=np.complex64)
        self.x_strided_COMPLEX64_t = np.empty(self.size * self.stride_factor, dtype=np.complex64)
        self.x_strided_COMPLEX64_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_COMPLEX64_t[i * self.stride_factor] = self.x_COMPLEX64_t[i]

        self.x_COMPLEX128_t = np.ones(self.size, dtype=np.complex128)
        self.x_strided_COMPLEX128_t = np.empty(self.size * self.stride_factor, dtype=np.complex128)
        self.x_strided_COMPLEX128_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_COMPLEX128_t[i * self.stride_factor] = self.x_COMPLEX128_t[i]

        self.x_COMPLEX256_t = np.ones(self.size, dtype=np.complex256)
        self.x_strided_COMPLEX256_t = np.empty(self.size * self.stride_factor, dtype=np.complex256)
        self.x_strided_COMPLEX256_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_COMPLEX256_t[i * self.stride_factor] = self.x_COMPLEX256_t[i]


    def test_simple_multiplication_one_by_one(self):

  
  
        l_y = self.l_1_1.matvec(self.x_INT32_t)
        csr_y = self.l_1_1_csr.matvec(self.x_strided_INT32_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_2.matvec(self.x_INT64_t)
        csr_y = self.l_1_2_csr.matvec(self.x_strided_INT64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_3.matvec(self.x_FLOAT32_t)
        csr_y = self.l_1_3_csr.matvec(self.x_strided_FLOAT32_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_4.matvec(self.x_FLOAT64_t)
        csr_y = self.l_1_4_csr.matvec(self.x_strided_FLOAT64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_5.matvec(self.x_FLOAT128_t)
        csr_y = self.l_1_5_csr.matvec(self.x_strided_FLOAT128_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_6.matvec(self.x_COMPLEX64_t)
        csr_y = self.l_1_6_csr.matvec(self.x_strided_COMPLEX64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_7.matvec(self.x_COMPLEX128_t)
        csr_y = self.l_1_7_csr.matvec(self.x_strided_COMPLEX128_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_8.matvec(self.x_COMPLEX256_t)
        csr_y = self.l_1_8_csr.matvec(self.x_strided_COMPLEX256_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  

  
  
        l_y = self.l_2_1.matvec(self.x_INT32_t)
        csr_y = self.l_2_1_csr.matvec(self.x_strided_INT32_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_2.matvec(self.x_INT64_t)
        csr_y = self.l_2_2_csr.matvec(self.x_strided_INT64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_3.matvec(self.x_FLOAT32_t)
        csr_y = self.l_2_3_csr.matvec(self.x_strided_FLOAT32_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_4.matvec(self.x_FLOAT64_t)
        csr_y = self.l_2_4_csr.matvec(self.x_strided_FLOAT64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_5.matvec(self.x_FLOAT128_t)
        csr_y = self.l_2_5_csr.matvec(self.x_strided_FLOAT128_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_6.matvec(self.x_COMPLEX64_t)
        csr_y = self.l_2_6_csr.matvec(self.x_strided_COMPLEX64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_7.matvec(self.x_COMPLEX128_t)
        csr_y = self.l_2_7_csr.matvec(self.x_strided_COMPLEX128_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_8.matvec(self.x_COMPLEX256_t)
        csr_y = self.l_2_8_csr.matvec(self.x_strided_COMPLEX256_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  



class CySparseSymCSRMultiplicationWithAStridedNumpyVectorTestCase(CySparseCSRMultiplicationWithANumpyVectorBaseTestCase):
    """
    Basic case: ``y = A * x`` with ``A`` **symmetric** and ``x`` **with** strides.
    """
    def setUp(self):
        self.nbr_of_elements = 10
        self.size = 100

        self.stride_factor = 10


  
  
        self.l_1_1 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=INT32_T)
        construct_sym_sparse_matrix(self.l_1_1, self.size, self.nbr_of_elements)

        self.l_1_1_csr = self.l_1_1.to_csr()
  
        self.l_1_2 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=INT64_T)
        construct_sym_sparse_matrix(self.l_1_2, self.size, self.nbr_of_elements)

        self.l_1_2_csr = self.l_1_2.to_csr()
  
        self.l_1_3 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT32_T)
        construct_sym_sparse_matrix(self.l_1_3, self.size, self.nbr_of_elements)

        self.l_1_3_csr = self.l_1_3.to_csr()
  
        self.l_1_4 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT64_T)
        construct_sym_sparse_matrix(self.l_1_4, self.size, self.nbr_of_elements)

        self.l_1_4_csr = self.l_1_4.to_csr()
  
        self.l_1_5 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=FLOAT128_T)
        construct_sym_sparse_matrix(self.l_1_5, self.size, self.nbr_of_elements)

        self.l_1_5_csr = self.l_1_5.to_csr()
  
        self.l_1_6 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX64_T)
        construct_sym_sparse_matrix(self.l_1_6, self.size, self.nbr_of_elements)

        self.l_1_6_csr = self.l_1_6.to_csr()
  
        self.l_1_7 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX128_T)
        construct_sym_sparse_matrix(self.l_1_7, self.size, self.nbr_of_elements)

        self.l_1_7_csr = self.l_1_7.to_csr()
  
        self.l_1_8 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT32_T, dtype=COMPLEX256_T)
        construct_sym_sparse_matrix(self.l_1_8, self.size, self.nbr_of_elements)

        self.l_1_8_csr = self.l_1_8.to_csr()
  

  
  
        self.l_2_1 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=INT32_T)
        construct_sym_sparse_matrix(self.l_2_1, self.size, self.nbr_of_elements)

        self.l_2_1_csr = self.l_2_1.to_csr()
  
        self.l_2_2 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=INT64_T)
        construct_sym_sparse_matrix(self.l_2_2, self.size, self.nbr_of_elements)

        self.l_2_2_csr = self.l_2_2.to_csr()
  
        self.l_2_3 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT32_T)
        construct_sym_sparse_matrix(self.l_2_3, self.size, self.nbr_of_elements)

        self.l_2_3_csr = self.l_2_3.to_csr()
  
        self.l_2_4 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT64_T)
        construct_sym_sparse_matrix(self.l_2_4, self.size, self.nbr_of_elements)

        self.l_2_4_csr = self.l_2_4.to_csr()
  
        self.l_2_5 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=FLOAT128_T)
        construct_sym_sparse_matrix(self.l_2_5, self.size, self.nbr_of_elements)

        self.l_2_5_csr = self.l_2_5.to_csr()
  
        self.l_2_6 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX64_T)
        construct_sym_sparse_matrix(self.l_2_6, self.size, self.nbr_of_elements)

        self.l_2_6_csr = self.l_2_6.to_csr()
  
        self.l_2_7 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX128_T)
        construct_sym_sparse_matrix(self.l_2_7, self.size, self.nbr_of_elements)

        self.l_2_7_csr = self.l_2_7.to_csr()
  
        self.l_2_8 = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=INT64_T, dtype=COMPLEX256_T)
        construct_sym_sparse_matrix(self.l_2_8, self.size, self.nbr_of_elements)

        self.l_2_8_csr = self.l_2_8.to_csr()
  



        self.x_INT32_t = np.ones(self.size, dtype=np.int32)
        self.x_strided_INT32_t = np.empty(self.size * self.stride_factor, dtype=np.int32)
        self.x_strided_INT32_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_INT32_t[i * self.stride_factor] = self.x_INT32_t[i]

        self.x_INT64_t = np.ones(self.size, dtype=np.int64)
        self.x_strided_INT64_t = np.empty(self.size * self.stride_factor, dtype=np.int64)
        self.x_strided_INT64_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_INT64_t[i * self.stride_factor] = self.x_INT64_t[i]

        self.x_FLOAT32_t = np.ones(self.size, dtype=np.float32)
        self.x_strided_FLOAT32_t = np.empty(self.size * self.stride_factor, dtype=np.float32)
        self.x_strided_FLOAT32_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_FLOAT32_t[i * self.stride_factor] = self.x_FLOAT32_t[i]

        self.x_FLOAT64_t = np.ones(self.size, dtype=np.float64)
        self.x_strided_FLOAT64_t = np.empty(self.size * self.stride_factor, dtype=np.float64)
        self.x_strided_FLOAT64_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_FLOAT64_t[i * self.stride_factor] = self.x_FLOAT64_t[i]

        self.x_FLOAT128_t = np.ones(self.size, dtype=np.float128)
        self.x_strided_FLOAT128_t = np.empty(self.size * self.stride_factor, dtype=np.float128)
        self.x_strided_FLOAT128_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_FLOAT128_t[i * self.stride_factor] = self.x_FLOAT128_t[i]

        self.x_COMPLEX64_t = np.ones(self.size, dtype=np.complex64)
        self.x_strided_COMPLEX64_t = np.empty(self.size * self.stride_factor, dtype=np.complex64)
        self.x_strided_COMPLEX64_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_COMPLEX64_t[i * self.stride_factor] = self.x_COMPLEX64_t[i]

        self.x_COMPLEX128_t = np.ones(self.size, dtype=np.complex128)
        self.x_strided_COMPLEX128_t = np.empty(self.size * self.stride_factor, dtype=np.complex128)
        self.x_strided_COMPLEX128_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_COMPLEX128_t[i * self.stride_factor] = self.x_COMPLEX128_t[i]

        self.x_COMPLEX256_t = np.ones(self.size, dtype=np.complex256)
        self.x_strided_COMPLEX256_t = np.empty(self.size * self.stride_factor, dtype=np.complex256)
        self.x_strided_COMPLEX256_t.fill(2)

        for i in xrange(self.size):
            self.x_strided_COMPLEX256_t[i * self.stride_factor] = self.x_COMPLEX256_t[i]


    def test_simple_multiplication_one_by_one(self):

  
  
        l_y = self.l_1_1.matvec(self.x_INT32_t)
        csr_y = self.l_1_1_csr.matvec(self.x_strided_INT32_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_2.matvec(self.x_INT64_t)
        csr_y = self.l_1_2_csr.matvec(self.x_strided_INT64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_3.matvec(self.x_FLOAT32_t)
        csr_y = self.l_1_3_csr.matvec(self.x_strided_FLOAT32_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_4.matvec(self.x_FLOAT64_t)
        csr_y = self.l_1_4_csr.matvec(self.x_strided_FLOAT64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_5.matvec(self.x_FLOAT128_t)
        csr_y = self.l_1_5_csr.matvec(self.x_strided_FLOAT128_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_6.matvec(self.x_COMPLEX64_t)
        csr_y = self.l_1_6_csr.matvec(self.x_strided_COMPLEX64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_7.matvec(self.x_COMPLEX128_t)
        csr_y = self.l_1_7_csr.matvec(self.x_strided_COMPLEX128_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_8.matvec(self.x_COMPLEX256_t)
        csr_y = self.l_1_8_csr.matvec(self.x_strided_COMPLEX256_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  

  
  
        l_y = self.l_2_1.matvec(self.x_INT32_t)
        csr_y = self.l_2_1_csr.matvec(self.x_strided_INT32_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_2.matvec(self.x_INT64_t)
        csr_y = self.l_2_2_csr.matvec(self.x_strided_INT64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_3.matvec(self.x_FLOAT32_t)
        csr_y = self.l_2_3_csr.matvec(self.x_strided_FLOAT32_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_4.matvec(self.x_FLOAT64_t)
        csr_y = self.l_2_4_csr.matvec(self.x_strided_FLOAT64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_5.matvec(self.x_FLOAT128_t)
        csr_y = self.l_2_5_csr.matvec(self.x_strided_FLOAT128_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_6.matvec(self.x_COMPLEX64_t)
        csr_y = self.l_2_6_csr.matvec(self.x_strided_COMPLEX64_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_7.matvec(self.x_COMPLEX128_t)
        csr_y = self.l_2_7_csr.matvec(self.x_strided_COMPLEX128_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_8.matvec(self.x_COMPLEX256_t)
        csr_y = self.l_2_8_csr.matvec(self.x_strided_COMPLEX256_t[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  



if __name__ == '__main__':
    unittest.main()
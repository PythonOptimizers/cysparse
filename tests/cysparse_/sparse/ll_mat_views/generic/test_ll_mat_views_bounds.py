# THIS FILE DOES NOT WORK

#!/usr/bin/env python

"""
This file tests the bounds of an :class:`LLSparseMatrixView` object.

     If this is a python script (.py), it has been automatically generated by the 'generate_code.py' script.

"""
from cysparse.sparse.ll_mat import *
from cysparse.types.cysparse_types import *
import numpy as np

import unittest

import sys

########################################################################################################################
# Tests
########################################################################################################################
class CySparseLLSparseMatrixBoundsBaseTestCase(unittest.TestCase):
    def setUp(self):
        pass

class CySparseLLSparseMatrixViewOutOfBoundsTestCase(CySparseLLSparseMatrixBoundsBaseTestCase):
    """
    Test out of bounds case.
    """
    def setUp(self):
        self.nbr_of_elements = 10
        self.nrow = 4
        self.ncol = 6


  
  
        self.l_1_1 = NewLinearFillLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, itype=INT32_T, dtype=COMPLEX64_T, row_wise=False)
        self.l_1_1_csr = self.l_1_1.to_csr()
  
        self.l_1_2 = NewLinearFillLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, itype=INT32_T, dtype=COMPLEX128_T, row_wise=False)
        self.l_1_2_csr = self.l_1_2.to_csr()
  
        self.l_1_3 = NewLinearFillLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, itype=INT32_T, dtype=COMPLEX256_T, row_wise=False)
        self.l_1_3_csr = self.l_1_3.to_csr()
  

  
  
        self.l_2_1 = NewLinearFillLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, itype=INT64_T, dtype=COMPLEX64_T, row_wise=False)
        self.l_2_1_csr = self.l_2_1.to_csr()
  
        self.l_2_2 = NewLinearFillLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, itype=INT64_T, dtype=COMPLEX128_T, row_wise=False)
        self.l_2_2_csr = self.l_2_2.to_csr()
  
        self.l_2_3 = NewLinearFillLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, itype=INT64_T, dtype=COMPLEX256_T, row_wise=False)
        self.l_2_3_csr = self.l_2_3.to_csr()
  



        self.x_COMPLEX64_t = np.ones(self.nrow, dtype=np.complex64)

        self.x_COMPLEX128_t = np.ones(self.nrow, dtype=np.complex128)

        self.x_COMPLEX256_t = np.ones(self.nrow, dtype=np.complex256)


    def test_simple_out_of_bound(self):

  
  
        l_y = self.l_1_1.matvec_htransp(self.x_COMPLEX64_t)
        csr_y = self.l_1_1_csr.matvec_htransp(self.x_COMPLEX64_t)
        for i in xrange(self.ncol):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_2.matvec_htransp(self.x_COMPLEX128_t)
        csr_y = self.l_1_2_csr.matvec_htransp(self.x_COMPLEX128_t)
        for i in xrange(self.ncol):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_1_3.matvec_htransp(self.x_COMPLEX256_t)
        csr_y = self.l_1_3_csr.matvec_htransp(self.x_COMPLEX256_t)
        for i in xrange(self.ncol):
            self.failUnless(l_y[i] == csr_y[i])
  

  
  
        l_y = self.l_2_1.matvec_htransp(self.x_COMPLEX64_t)
        csr_y = self.l_2_1_csr.matvec_htransp(self.x_COMPLEX64_t)
        for i in xrange(self.ncol):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_2.matvec_htransp(self.x_COMPLEX128_t)
        csr_y = self.l_2_2_csr.matvec_htransp(self.x_COMPLEX128_t)
        for i in xrange(self.ncol):
            self.failUnless(l_y[i] == csr_y[i])
  
        l_y = self.l_2_3.matvec_htransp(self.x_COMPLEX256_t)
        csr_y = self.l_2_3_csr.matvec_htransp(self.x_COMPLEX256_t)
        for i in xrange(self.ncol):
            self.failUnless(l_y[i] == csr_y[i])
  

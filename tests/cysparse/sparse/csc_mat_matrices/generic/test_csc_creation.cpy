#!/usr/bin/env python

"""
This file tests the creation of :class:`CSCSparseMatrix` matrices from :class:`LLSparesMatrix` matrices.

We test **all** types and the symmetric and general cases.
We only use the real parts of complex numbers.


     If this is a python script (.py), it has been automatically generated by the 'generate_code.py' script.

"""
from cysparse.sparse.ll_mat import *
from cysparse.types.cysparse_types import *
import numpy as np

import unittest

import sys

########################################################################################################################
# Helpers
########################################################################################################################
def construct_sym_sparse_matrix(A, n, nbr_elements):
    for i in xrange(nbr_elements):
        k = i % n
        p = (i % 2 + 1) % n
        if k >= p:
            A[k, p] = i / 3
        else:
            A[p, k] = i / 3

def construct_sparse_matrix(A, n, nbr_elements):
    for i in xrange(nbr_elements):
        k = i % n
        p = (i % 2 + 1) % n
        A[p, k] = i / 3

########################################################################################################################
# Tests
########################################################################################################################
class CySparseCSCCreationBaseTestCase(unittest.TestCase):
    def setUp(self):
        pass

class CySparseCSCCreationFromLLSparseMatrixTestCase(CySparseCSCCreationBaseTestCase):
    def setUp(self):
        self.nbr_of_elements = 10
        self.size = 100
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in type_list %}
        self.l_@outerloop.index@_@loop.index@ = NewLLSparseMatrix(size=self.size, size_hint=self.nbr_of_elements, itype=@index_type|type2enum@, dtype=@element_type|type2enum@)
        construct_sparse_matrix(self.l_@outerloop.index@_@loop.index@, self.size, self.nbr_of_elements)

        self.l_@outerloop.index@_@loop.index@_csc = self.l_@outerloop.index@_@loop.index@.to_csc()
  {% endfor %}
{% endfor %}

    def test_elements_one_by_one(self):
        """
        We test if both :class:`LLSparseMatrix` and corresponding :class:`CSCSparseMatrix` are equal, element by elmeent.
        """
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in type_list %}
        for i in xrange(self.size):
            for j in xrange(self.size):
                self.failUnless(self.l_@outerloop.index@_@loop.index@[i, j] == self.l_@outerloop.index@_@loop.index@_csc[i, j])
  {% endfor %}
{% endfor %}

    def test_symmetric_attribute(self):
        """
        We test if the ``is_symmetric`` attribute is the same for both matrices.
        """
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in type_list %}
        self.failUnless(self.l_@outerloop.index@_@loop.index@.is_symmetric == self.l_@outerloop.index@_@loop.index@_csc.is_symmetric == False)
  {% endfor %}
{% endfor %}


class CySparseCSCCreationFromSymmetricLLSparseMatrixTestCase(CySparseCSCCreationBaseTestCase):
    def setUp(self):
        self.nbr_of_elements = 10
        self.size = 100
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in type_list %}
        self.l_@outerloop.index@_@loop.index@ = NewLLSparseMatrix(is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=@index_type|type2enum@, dtype=@element_type|type2enum@)
        construct_sym_sparse_matrix(self.l_@outerloop.index@_@loop.index@, self.size, self.nbr_of_elements)

        self.l_@outerloop.index@_@loop.index@_csc = self.l_@outerloop.index@_@loop.index@.to_csc()
  {% endfor %}
{% endfor %}

    def test_elements_one_by_one(self):
        """
        We test if both :class:`LLSparseMatrix` and corresponding :class:`CSCSparseMatrix` are equal, element by elmeent.
        """
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in type_list %}
        for i in xrange(self.size):
            for j in xrange(self.size):
                self.failUnless(self.l_@outerloop.index@_@loop.index@[i, j] == self.l_@outerloop.index@_@loop.index@_csc[i, j])
  {% endfor %}
{% endfor %}

    def test_symmetric_attribute(self):
        """
        We test if the ``is_symmetric`` attribute is the same for both matrices.
        """
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in type_list %}
        self.failUnless(self.l_@outerloop.index@_@loop.index@.is_symmetric == self.l_@outerloop.index@_@loop.index@_csc.is_symmetric == True)
  {% endfor %}
{% endfor %}


if __name__ == '__main__':
    unittest.main()
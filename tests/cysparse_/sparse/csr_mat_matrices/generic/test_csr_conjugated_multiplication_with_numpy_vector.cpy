#!/usr/bin/env python

"""
This file tests the conjugated multiplication of an :class:`CSRSparseMatrix` matrix with a :program:`NumPy` vector.

We test **all** types and the symmetric and general cases. We also test strided vectors.


     If this is a python script (.py), it has been automatically generated by the 'generate_code.py' script.

"""
from cysparse.sparse.ll_mat import *
from cysparse.types.cysparse_types import *
import numpy as np

import unittest

import sys

########################################################################################################################
# Helpers
########################################################################################################################
def construct_sym_sparse_matrix(A, n, nbr_elements):
    for i in xrange(nbr_elements):
        k = i % n
        p = (i % 2 + 1) % n
        if k >= p:
            A[k, p] = i / 3
        else:
            A[p, k] = i / 3

def construct_dense_matrix(A, m, n, nbr_elements):
    i = 0
    j = -1
    for k in xrange(nbr_elements):
        j = j + 1
        if j % n == 0:
            i = i + 1
            if i >= m:
                break

        A[i, j] = (i + j) / 3

########################################################################################################################
# Tests
########################################################################################################################
class CySparseCSRConjugatedMultiplicationWithANumpyVectorBaseTestCase(unittest.TestCase):
    def setUp(self):
        pass

class CySparseCSRConjugatedMultiplicationWithANumpyVectorTestCase(CySparseCSRConjugatedMultiplicationWithANumpyVectorBaseTestCase):
    """
    Basic case: ``y = conj(A) * x`` with ``A`` **non** symmetric and ``x`` and ``y`` without strides.
    """
    def setUp(self):
        self.nbr_of_elements = 10
        self.nrow = 80
        self.ncol = 100

{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in complex_list %}
        #self.l_@outerloop.index@_@loop.index@ = NewLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, size_hint=self.nbr_of_elements, itype=@index_type|type2enum@, dtype=@element_type|type2enum@)
        #construct_dense_matrix(self.l_@outerloop.index@_@loop.index@, self.nrow, self.ncol, self.nbr_of_elements)

        self.l_@outerloop.index@_@loop.index@ = NewLinearFillLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, itype=@index_type|type2enum@, dtype=@element_type|type2enum@, row_wise=False)

        self.l_@outerloop.index@_@loop.index@_csr = self.l_@outerloop.index@_@loop.index@.to_csr()
  {% endfor %}
{% endfor %}

{% for element_type in complex_list %}
        self.x_@element_type@ = np.empty(self.ncol, dtype=np.@element_type|type2enum|cysparse_type_to_numpy_type@)
        self.x_@element_type@.fill(1+2j)
{% endfor %}

    def test_simple_multiplication_one_by_one(self):
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in complex_list %}
        l_y = self.l_@outerloop.index@_@loop.index@.matvec_conj(self.x_@element_type@)
        csr_y = self.l_@outerloop.index@_@loop.index@_csr.matvec_conj(self.x_@element_type@)
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  {% endfor %}
{% endfor %}


class CySparseSymCSRConjugatedMultiplicationWithANumpyVectorTestCase(CySparseCSRConjugatedMultiplicationWithANumpyVectorBaseTestCase):
    """
    Basic case: ``y = conj(A) * x`` with ``A`` symmetric and ``x`` and ``y`` without strides.
    """
    def setUp(self):
        self.nbr_of_elements = 10
        self.size = 100
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in complex_list %}
        #self.l_@outerloop.index@_@loop.index@ = NewLLSparseMatrix(__is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=@index_type|type2enum@, dtype=@element_type|type2enum@)
        #construct_sym_sparse_matrix(self.l_@outerloop.index@_@loop.index@, self.size, self.nbr_of_elements)

        self.l_@outerloop.index@_@loop.index@ = NewLinearFillLLSparseMatrix(size=self.size, itype=@index_type|type2enum@, dtype=@element_type|type2enum@, row_wise=False, is_symmetric=True)

        self.l_@outerloop.index@_@loop.index@_csr = self.l_@outerloop.index@_@loop.index@.to_csr()
  {% endfor %}
{% endfor %}

{% for element_type in complex_list %}
        self.x_@element_type@ = np.empty(self.size, dtype=np.@element_type|type2enum|cysparse_type_to_numpy_type@)
        self.x_@element_type@.fill(1+2j)
{% endfor %}

    def test_simple_multiplication_one_by_one(self):
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in complex_list %}
        l_y = self.l_@outerloop.index@_@loop.index@.matvec_conj(self.x_@element_type@)
        csr_y = self.l_@outerloop.index@_@loop.index@_csr.matvec_conj(self.x_@element_type@)
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  {% endfor %}
{% endfor %}


class CySparseCSRConjugatedMultiplicationWithAStridedNumpyVectorTestCase(CySparseCSRConjugatedMultiplicationWithANumpyVectorBaseTestCase):
    """
    Basic case: ``y = conj(A) * x`` with ``A`` **symmetric** and ``x`` **with** strides.
    """
    def setUp(self):
        self.nbr_of_elements = 10
        self.nrow = 80
        self.ncol = 70

        self.stride_factor = 10

{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in complex_list %}
        #self.l_@outerloop.index@_@loop.index@ = NewLLSparseMatrix(__is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=@index_type|type2enum@, dtype=@element_type|type2enum@)
        #construct_sym_sparse_matrix(self.l_@outerloop.index@_@loop.index@, self.size, self.nbr_of_elements)

        self.l_@outerloop.index@_@loop.index@ = NewLinearFillLLSparseMatrix(nrow=self.nrow, ncol=self.ncol, itype=@index_type|type2enum@, dtype=@element_type|type2enum@, row_wise=False)

        self.l_@outerloop.index@_@loop.index@_csr = self.l_@outerloop.index@_@loop.index@.to_csr()
  {% endfor %}
{% endfor %}

{% for element_type in complex_list %}
        self.x_@element_type@ = np.empty(self.ncol, dtype=np.@element_type|type2enum|cysparse_type_to_numpy_type@)
        self.x_@element_type@.fill(1+2j)
        self.x_strided_@element_type@ = np.empty(self.ncol * self.stride_factor, dtype=np.@element_type|type2enum|cysparse_type_to_numpy_type@)
        self.x_strided_@element_type@.fill(2)

        for i in xrange(self.ncol):
            self.x_strided_@element_type@[i * self.stride_factor] = self.x_@element_type@[i]
{% endfor %}

    def test_simple_multiplication_one_by_one(self):
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in complex_list %}
        l_y = self.l_@outerloop.index@_@loop.index@.matvec_conj(self.x_@element_type@)
        csr_y = self.l_@outerloop.index@_@loop.index@_csr.matvec_conj(self.x_strided_@element_type@[::self.stride_factor])
        for i in xrange(self.nrow):
            self.failUnless(l_y[i] == csr_y[i])
  {% endfor %}
{% endfor %}


class CySparseSymCSRConjugatedMultiplicationWithAStridedNumpyVectorTestCase(CySparseCSRConjugatedMultiplicationWithANumpyVectorBaseTestCase):
    """
    Basic case: ``y = conj(A) * x`` with ``A`` **symmetric** and ``x`` **with** strides.
    """
    def setUp(self):
        self.nbr_of_elements = 10
        self.size = 100

        self.stride_factor = 10

{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in complex_list %}
        #self.l_@outerloop.index@_@loop.index@ = NewLLSparseMatrix(__is_symmetric=True, size=self.size, size_hint=self.nbr_of_elements, itype=@index_type|type2enum@, dtype=@element_type|type2enum@)
        #construct_sym_sparse_matrix(self.l_@outerloop.index@_@loop.index@, self.size, self.nbr_of_elements)

        self.l_@outerloop.index@_@loop.index@ = NewLinearFillLLSparseMatrix(size=self.size, itype=@index_type|type2enum@, dtype=@element_type|type2enum@, row_wise=False, is_symmetric=True)


        self.l_@outerloop.index@_@loop.index@_csr = self.l_@outerloop.index@_@loop.index@.to_csr()
  {% endfor %}
{% endfor %}

{% for element_type in complex_list %}
        self.x_@element_type@ = np.empty(self.size, dtype=np.@element_type|type2enum|cysparse_type_to_numpy_type@)
        self.x_@element_type@.fill(1+2j)
        self.x_strided_@element_type@ = np.empty(self.size * self.stride_factor, dtype=np.@element_type|type2enum|cysparse_type_to_numpy_type@)
        self.x_strided_@element_type@.fill(2)

        for i in xrange(self.size):
            self.x_strided_@element_type@[i * self.stride_factor] = self.x_@element_type@[i]
{% endfor %}

    def test_simple_multiplication_one_by_one(self):
{% for index_type in index_list %}
  {% set outerloop = loop %}
  {% for element_type in complex_list %}
        l_y = self.l_@outerloop.index@_@loop.index@.matvec_conj(self.x_@element_type@)
        csr_y = self.l_@outerloop.index@_@loop.index@_csr.matvec_conj(self.x_strided_@element_type@[::self.stride_factor])
        for i in xrange(self.size):
            self.failUnless(l_y[i] == csr_y[i])
  {% endfor %}
{% endfor %}


if __name__ == '__main__':
    unittest.main()